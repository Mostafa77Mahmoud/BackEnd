Context (read repository first):
- Repo root currently contains files including: api_server.py, config.py, doc_processing.py, remote_api.py, utils.py, plus the new app/ folder and prompts/ folder the agent created. BACKEND_DOCUMENTATION.md and TECHNICAL_DIAGRAMS.md are authoritative context.
- Constraints / hard rules:
  1. Keep Flask. Do NOT migrate to FastAPI.
  2. Default jurisdiction = "Egypt" when not provided.
  3. DO NOT introduce or depend on any LLM_JSON_VALIDATOR module at this stage.
  4. Any file intended only for tests/demo must begin with:
     # NOTE: This file is for testing purposes only
  5. Do not commit real secrets; keep only .env.example with placeholders.
  6. Preserve existing LibreOffice headless pipeline for DOCX->PDF.
  7. Safety: Before permanently deleting any original root-level file, move it to `backups/original_root_files/` and only delete that backup after full functional verification and a checkpoint that proves parity.

Primary objective:
Finish and fix the incomplete restructuring so the backend is functional and matches the agreed API contract and prompt files. Specifically: implement missing endpoints, consolidate or shim legacy top-level modules into the app package, ensure prompts content and placeholders are correct, add minimal tests and examples, update docs with concrete examples, and create checkpoints with clear commits.

**Crucial extra requirement (user request):** For each of these original files:
  - `api_server.py`
  - `config.py`
  - `doc_processing.py`
  - `remote_api.py`
  - `utils.py`

You **must** ensure that every function, important code block, and overall functionality they provided is present and working after the restructure (either moved to canonical `app/...` modules or available via a one-line shim import). Procedure:
1. Create a `backups/original_root_files/` directory and move the original root files there (commit this move).
2. For each original file, produce a short **mapping report** (file: `migrations/<filename>_move_report.md`) that lists the exported symbols / top-level functions/classes from the original and where they were moved to (or if a shim was created). Example entry:
   - `api_server.py`: `create_app()` -> moved to `app/__init__.py:create_app`, `legacy_run()` -> shim `run_compat.py` -> imports from `app`
3. Implement shims if needed (one-line import stubs) in the repo root with comment `# NOTE: shim — kept for backward compatibility`.
4. Run automated sanity checks:
   - Start the Flask app (python run.py or equivalent).
   - Run curl smoke tests against endpoints (health, /api/analyze (basic), /api/rules, /api/analysis/<fake-id>).
   - Run unit tests under `tests/` if environment supports it.
5. Only after successful sanity checks and verification that every public function from the original files exists and routes respond as expected, **delete** the backup copies under `backups/original_root_files/` in a final commit. If any step fails, restore from backup and stop; report the exact failing points.

Exact tasks (perform in this order; create a checkpoint after each major step):

STEP 0 — Preflight (read/scan)
- Read BACKEND_DOCUMENTATION.md and TECHNICAL_DIAGRAMS.md to understand current behavior.
- Produce an initial summary of root-level duplicate files and the functions they expose (list exported symbols).

STEP 1 — Consolidate code layout (non-fussy)
- Move canonical code into `app/` modules (app/utils, app/services, app/routes) if not already present.
- For each original root file:
  - Move it to `backups/original_root_files/` and commit the move as `chore: backup root <filename>`.
  - Create migration report `migrations/<filename>_move_report.md` describing where each top-level function/class now lives or which shim wraps it.
  - If you cannot fully move some functionality safely, create a shim in repo root like:
    # NOTE: shim — kept for backward compatibility
    from app.utils.doc_processing import <function_name>  # moved from root
- Ensure no duplicate implementations remain active in import path. Prefer `app/` as canonical.

STEP 2 — Implement / fix endpoints in app/routes
- Ensure the following endpoints exist under `/api` prefix and are wired in Flask routes (complete implementations or functional stubs that return the correct responses):

1) POST /api/analyze
   - Accept file OR JSON body with `text`.
   - Accept `analysis_type` array of ["sharia","legal"].
   - Accept `jurisdiction` (default "Egypt").
   - Behavior: store contract version metadata (include original_filename, original_file_path, original_format, text_plain, markdown) in in-repo storage (simple JSON files under `data/contracts/` or in-memory if DB not configured). Return 202 with `analysis_id` and `status: queued`.
   - Implementation may start a background thread to perform analysis; if background not possible, return queued and set status to processing and immediately run a synchronous placeholder that produces minimal `sharia_results` and `legal_results` arrays for testing.

2) GET /api/analysis/<analysis_id>
   - Return object with `analysis_id`, `contract_id`, `status`, `sharia_results`, `legal_results`, `retrieval_debug` optional.
   - Example response in docstring.

3) POST /api/generate_from_brief
   - Call CONTRACT_GENERATION_PROMPT via existing LLM client wrapper and return `{contract_id, ast, markdown}`.

4) POST /api/generate_modified_contract
   - Apply confirmed_modifications to stored contract and return `new_version_id` and docx path.

5) POST /api/generate_marked_contract (compatibility)
   - Ensure compatibility if this endpoint existed before.

6) POST /api/interact
   - Use INTERACTION_PROMPT_SHARIA or INTERACTION_PROMPT_LEGAL depending on `mode`.

7) POST /api/review_modification
   - Use REVIEW_MODIFICATION_PROMPT_* and return its JSON output; if output is not valid JSON, return an error structure pointing to raw LLM output for human review (do not attempt automatic JSON fixing).

8) Admin: /api/rules CRUD
   - Basic in-memory or file-backed CRUD endpoints.

- Each endpoint must have a docstring showing example request and response (one-liner JSON).

STEP 3 — Prompts correctness
- Ensure `prompts/` contains:
  - EXTRACTION_PROMPT.txt
  - SYS_PROMPT_SHARIA_ANALYSIS.txt
  - SYS_PROMPT_LEGAL_ANALYSIS.txt
  - CONTRACT_GENERATION_PROMPT.txt
  - CONTRACT_REGENERATION_PROMPT.txt
  - INTERACTION_PROMPT_SHARIA.txt
  - INTERACTION_PROMPT_LEGAL.txt
  - REVIEW_MODIFICATION_PROMPT_SHARIA.txt
  - REVIEW_MODIFICATION_PROMPT_LEGAL.txt
  - (Optional) EXTRACTION_VALIDATION_PROMPT.txt, RAG_PROMPT_TEMPLATE.txt
- Each prompt file must start with:
  AUTO-GENERATED by Agent — leave this line for future reference
  <!-- AGENT_CONTEXT_BLOCK_START -->
  (AGENT: keep this block; you may add repo-specific contextual hints)
  <!-- AGENT_CONTEXT_BLOCK_END -->
- For legal prompts: author them to match style/precision of existing sharia prompts; include the exact JSON schema fields (law_ref, reference_url, suggestion).

STEP 4 — Tests & demo checks
- Add tests/test_endpoints_basic.py with at least:
  - POST /api/analyze returns 202 and analysis_id (use simple JSON `text` payload).
  - GET /api/analysis/<id> returns expected structure.
- Add a `scripts/smoke_test.sh` (executable) that runs curl commands for: health, POST /api/analyze (JSON text), GET /api/analysis/<id>, GET /api/rules.
  - Add header comment `# NOTE: This file is for testing purposes only` at top of any test-only script.

STEP 5 — Verify functional parity with originals
- For each function exported by original root files, ensure it exists in the canonical app modules or shim and runs.
- Run the Flask app and execute smoke_test.sh. Confirm:
  - Health endpoint returns 200.
  - POST /api/analyze accepted and returned analysis_id.
  - GET /api/analysis/<analysis_id> returns structure (status may be queued/processing/done).
  - POST /api/generate_from_brief returns contract_id and markdown.
- If any check fails, rollback the deletion of backups and report issues.

STEP 6 — Cleanup & final deletion
- If all verifications pass, delete `backups/original_root_files/` in a final commit: message `chore: remove backed-up root files after successful migration`.
- Create a final checkpoint and provide its ID.

Commit & checkpoint practice:
- Make granular commits with messages like:
  - `chore: backup root api_server.py`
  - `refactor: move doc_processing to app/utils/doc_processing.py`
  - `feat(api): implement POST /api/analyze (basic)`
  - `test: add smoke_test.sh and tests/test_endpoints_basic.py`
  - `chore: remove backed-up root files after successful migration`
- Create checkpoint after STEP 2 (endpoints implemented) and final checkpoint after STEP 6.

Final report (what to paste back here when done):
1. Short summary of changes (files moved, new files, endpoints implemented).  
2. Checkpoint ID (or commit SHAs).  
3. Test results (smoke_test output).  
4. Any endpoints still stubbed and what's needed to complete them.

Operational constraints:
- Use Build Mode; do not run long autonomous jobs (>20 minutes) without approval.
- If any ambiguity remains, ask only one focused clarifying question; otherwise proceed with best engineering judgment.

Proceed now.
